import pytest
from unittest.mock import patch, MagicMock
from blueprints.vulnerability_scanner import analyze_rules, get_firewall_rules
from app import create_app  # Import your app factory

app = create_app()

# This file contains unit tests for the vulnerability scanner blueprint.
# It tests the logic for identifying vulnerable firewall rules and the Flask route for fetching firewall rules.

def test_analyze_rules_detects_vulnerable():
    # Test that analyze_rules correctly identifies inbound 'allow' rules as vulnerable
    rules = [
        {"Direction": "in", "Action": "allow", "Rule Name": "TestRule", "LocalPort": "80"},
        {"Direction": "out", "Action": "allow", "Rule Name": "SafeRule", "LocalPort": "443"},
    ]
    result = analyze_rules(rules)
    assert "TestRule" in result
    assert "SafeRule" not in result

def test_analyze_rules_empty():
    # Test that analyze_rules returns an empty dict when no rules are provided
    rules = []
    result = analyze_rules(rules)
    assert result == {}

@patch("blueprints.vulnerability_scanner.platform.system")
@patch("blueprints.vulnerability_scanner.subprocess.run")
def test_get_firewall_rules_windows(mock_run, mock_system):
    # Test get_firewall_rules route for Windows, mocking subprocess and platform
    mock_system.return_value = "Windows"
    mock_run.return_value = MagicMock(stdout="Rule Name: TestRule\nDirection: in\nAction: allow\nLocalPort: 80\n")
    with app.app_context():
        response = get_firewall_rules()
        data = response.get_json()
        assert "TestRule" in data["vulnerable_rules"]

@patch("blueprints.vulnerability_scanner.platform.system")
def test_get_firewall_rules_unsupported_os(mock_system):
    # Test get_firewall_rules route for unsupported OS
    mock_system.return_value = "Solaris"
    with app.app_context():
        response = get_firewall_rules()
        data = response.get_json()
        assert data["error"] == "Unsupported OS"